//** version v0.3
#include <iostream>

using namespace std;

// ** 1. 데이터 추가 (새로운 공간 확보)
// ** 2. 데이터 삭제 (배열에서는 실제로 삭제하려고 생성하지는 않는다.)
   //데이터를 불러올때나 텍스쳐를 불러올때 주로 쓰인다.
// ** 3. 데이터를 삽입할 수 있는 공간의 크기
// ** 4. 현재 삽입되어있는 원소의 개수
// ** 5. 컨테이너(뭔가를 담아내기 위한 공간)의 시작 지점
// ** 6. 컨테이너의 종료 지점

//  0 0000000 = 0
//  0 0000001 = 1
//  0 0000010 = 2
//  0 0000011 = 3
//  0 0000100 = 4
//  0 0000101 = 5
//  0 0000110 = 6
//  0 0000111 = 7
//  0 0001000 = 8
//  0 0001001 = 9
//  0 0001010 = 10
//  0 0001011 = 11
//  0 0001100 = 12
//  0 0001101 = 13
//  0 0001110 = 14
//  0 0001111 = 15
//  0 0010000 = 16
//  .
//  .
//  .
//  .
//  0 1111111 = 127 + 1
//  1 0000000 = -1


//   0 0010000 = 16
// - 0 0000110 = 6
//-----------------
// (16 - 6 = 16 + (-6))  
//
// ** 2의 보수 시작
// 0 0 0 0 0 1 1 0 = 6
// 1 1 1 1 1 1 1 1
// -------------------
// 1 1 1 1 1 0 0 1 + 1
// 11111001 + 1
// 11111010 = - 6
// 
//   00010000 = 16
// + 11111010 = -6
// -------------------
//   00001010
//   00001010 = 10
// 
//   0 00000110


int main(void)
{
	/********************
	 
	  char str1[2][5] = {
	  {'A', 'B', 'C', 'D'},
	  {'E', 'F', 'G', 'H'}
	  };

	  char* str2[2] = {
	  {(char*) "ABCD"},
	  {(char*) "EFGH"}
	  };

	  // 선생님 풀이
	  for (int i = 0; i < 5; ++i)
	      cout << (*str1)[i];
	  cout << endl;
	  printf_s("%s\n", str2[0]);

	  // 내가 한 풀이
	  cout << str2[0] << endl;
	  cout << str2[0] + 1 << endl;
	  cout << str2[0] + 2 << endl;
	  // 맨끝의 단어 D와 H는 출력해봤습니다.
	  cout << str2[0] + 3 << endl;
	  cout << str2[1] + 3 << endl;
	  // 직접접근으로 하나의 알파벳을 출력해보기 숙제
	
	*********************/

	/*
	// ** 양수 표현의
	char n = 127;
	n += 1;
	printf_s("%d", n);
	*/

	/*
	// ** +연산과 -연산중 컴퓨터에서 좋은 계산법은 
	char n = 16;
	n += -6;    // 이게 컴퓨터에선 좋은 계산법이다.
	n -= 6;
    printf_s("%d", n);
	*/

	/*
	char n = 16;
	printf_s("%d", n >> 1);  // C에서만 가능하다 shift 연산자 >>
	*/

	/*
	//** 나누기를 해야 할 때에는 * 기로 대체할 수 있을지 확인해보고
	int n = 1920 / 2;
	// int n = 1920 * 0.5f;


	printf_s("%d", n);

	//** 아래와 같이 쉬프트 연산자로 사용할 수 있을지 확인해보자.
	// printf_s("%d", n >> 1);

	*/

	//  ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ

	/*
	const int MAX = 16;
	int Vector(MAX);

	int Length = 10;

	for (int i = 0; i < Length; ++i)
	{
		cout << Vector[i] << endl;
	}
	*/

	/*
	//** 배열은 0이 아닌값으로만 초기화가 가능하다.
	//** 배열은 상수값으로만 초기화가 가능하다.

	//** 아래와 같이 사용한다면 위 조건은 무시할 수 있다.

	int Size = 0;
	int iter = 0;
	int* Vector = new int[Size];  // 동적할당을 할때에는 변수도 넣을 수 있고 0도 넣을 수 있다. (이 형태는 배열이 아니기 때문에)


	Vector[iter];
	*/

	//** 배열은 아니지만 배열처럼 사용할 수 있다.
	int Size = 10;
	int iter = 0;
	int* Vector = new int[Size];  // 동적할당을 할때에는 변수도 넣을 수 있고 0도 넣을 수 있다. (이 형태는 배열이 아니기 때문에)


	for (int i = 0; i < Size; ++i)
		Vector[i] = i;

	for (int i = 0; i < Size; ++i)
		cout << Vector[i] << endl;

	for (int i = 0; i < 11; ++i)
		cout << Vector[iter++] << endl;

	Vector[iter++];


	// 배열의 길이는 2^n 이다.
	// 컴퓨터는 더하기의 기능은 있고 빼기의 기능은 없다.

	return 0;
}

//1주차
/*
//배열의 장점
  직접 접근이 가능하다. 직접 접근이 가능한 경우는 거의 없다.
  이것은 큰 장점이다. (직접 접근 경우는 두어개 정도밖에 없다.)
  동일한 크기로 나열되어 있다. >> 접근속도가 항상 일정하다. ('빠르다' 가 아니다. X)

// 배열의 단점
  배열의 길이를 바꿀수가 없다. >> 데이터 동적변환이 불가능하다.
  이는 치명적인 단점이다.
  데이터를 어디에 뒀는지 알수가 없다.

// 데이터의 복사와 이동
 데이터의 복사와 데이터의 이동 중
 이동이 더 시간이 걸린다. 그 데이터를 복사 후 기존 데이터는 삭제의 과정이기 때문에
*/

// 2주차
/*
 배열의 기능을 늘려주는 기능과 삭제기능

// ** 1. 데이터 추가 (새로운 공간 확보)
// ** 2. 데이터 삭제 (배열에서는 실제로 삭제하려고 생성하지는 않는다.)
	  //데이터를 불러올때나 텍스쳐를 불러올때 주로 쓰인다.
// ** 3. 데이터를 삽입할 수 있는 공간의 크기
// ** 4. 현재 삽입되어있는 원소의 개수
// ** 5. 컨테이너(뭔가를 담아내기 위한 공간)의 시작 지점
// ** 6. 컨테이너의 종료 지점

// ** 1. 왜 되지?
// ** 2. 왜 안 되지?

// ** 원인분석 (구글에 'msdn printf' 등 msdn과 함께 검색을 하면 설명이 나온다.)




*/